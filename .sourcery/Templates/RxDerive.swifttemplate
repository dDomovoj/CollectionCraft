<%
func foo() -> String {
    return "bar"
}

func rxDerivedTypes() -> [Type] {
    types.all.filter { $0.allMethods.contains { $0.annotations["rx"] != nil } }
}

func isPublic(_ method: SourceryMethod) -> Bool {
    method.accessLevel == "public"
}

func rxDerivedMethods(for type: Type) -> [SourceryMethod] {
    type.allMethods.filter { isPublic($0) && $0.annotations["rx"] != nil }
}

func stringifyParamsForMethodInterface(of method: SourceryMethod) -> String {
    let input = method.name
    let from = (input as NSString).range(of: "(").location
    let to = (input as NSString).range(of: ")", options: .backwards).location
    let result = String(input.dropFirst(from + 1).dropLast((input as NSString).length - to - 1))
        .components(separatedBy: ",").dropLast().joined(separator: ",")
        .components(separatedBy: " ").filter { $0.count > 0 }.joined(separator: " ")
    return result
//    let params = method.parameters.dropLast()
//    let pairs = params.map {
//        ($0.argumentLabel ?? "_")
//            + "\($0.name == $0.argumentLabel ? "" : " \($0.name)"): \(stringTypeName(from: $0.typeName))"
//            + (defaultParamValueIfPresent($0).map { " = \($0)" } ?? "")
//    }
//    return pairs.joined(separator: ", ")
}

func stringTypeName(from typeName: TypeName) -> String {
    typeName.actualTypeName?.name ?? typeName.name
}

func defaultParamValueIfPresent(_ param: MethodParameter) -> String? {
    param.defaultValue
}

func resultType(of method: SourceryMethod) -> String {
    let completionParam = method.parameters.last!
    if completionParam.typeName.name.contains("AnyHandler") { return "Void" }

    return "\(completionParam.typeName.generic!.typeParameters.first!.typeName)"
}

func stringifyParamsForMethodCall(of method: SourceryMethod) -> String {
    let params = method.parameters.dropLast()
    let pairs = params.map { ($0.argumentLabel == nil ? "" : "\($0.argumentLabel!): ") + $0.name }
    return pairs.joined(separator: ", ")
}

-%>
import RxSwift
import RxUtils
import Utils
import Models
<%_ %>
<% for type in rxDerivedTypes() { -%>
    <%_ %>// MARK: - <%= type.name %>
    <%_ if type.based["ReactiveCompatible"] == nil { -%>
        <%_ %>
        <%_ %>extension <%= type.name %>: ReactiveCompatible { }
    <% } %>
    <%_ %>public extension Reactive where Base: <%= type.name %> {
        <% for method in rxDerivedMethods(for: type) { -%>
            <%_ %>
            <%_ %>  func <%= method.callName %>(<%= stringifyParamsForMethodInterface(of: method) %>) -> Single<<%= resultType(of: method) %>> {
            <%_ %>      .single { [base] event in
            <%_ %>          base.<%= method.callName %>(<%= stringifyParamsForMethodCall(of: method) %>) { $0 >> event }
            <%_ %>      }
            <%_ %>  }
        <% } %>
    <%_ %>}
<% } %>
